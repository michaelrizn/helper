// api.js
window.Api = {
  "API - HTTP Методы": {
    "GET": "Получение данных с сервера. Пример: GET /users",
    "POST": "Создание нового ресурса. Пример: POST /users",
    "PUT": "Полное обновление ресурса. Пример: PUT /users/1",
    "PATCH": "Частичное обновление ресурса. Пример: PATCH /users/1",
    "DELETE": "Удаление ресурса. Пример: DELETE /users/1",
    "HEAD": "Получение метаданных ресурса без тела ответа",
    "OPTIONS": "Получение поддерживаемых методов для ресурса",
    "CONNECT": "Установка туннеля через прокси-сервер. Пример: CONNECT proxy-server:443",
    "TRACE": "Диагностика маршрута запроса. Пример: TRACE /path"
  },
  "API - REST - Основные концепции": {
    Определение: "REST — архитектурный стиль для веб-сервисов на базе HTTP",
    "GET /resource": "Получение ресурса",
    "POST /resource": "Создание ресурса",
    "PUT /resource/{id}": "Полное обновление ресурса",
    "PATCH /resource/{id}": "Частичное обновление ресурса",
    "DELETE /resource/{id}": "Удаление ресурса",
    "Status Codes": "HTTP коды ответа для результатов запроса (200, 201, 400, 404, 500)",
    Authentication: "OAuth 2.0 или JWT для авторизации",
    HATEOAS: "Навигация по API через гиперссылки в ответах",
    Versioning: "Версионирование через URL или заголовки",
    "Rate Limiting": "Ограничение количества запросов",
    Caching: "Кэширование для оптимизации",
    "Content Negotiation": "Согласование формата данных (JSON, XML) через заголовки",
    "Error Handling": "Стандартизированные ответы об ошибках",
    "API Documentation": "Документация через Swagger/OpenAPI",
  },
  "API - SOAP - Основные концепции": {
    Определение: "SOAP — протокол обмена структурированными XML-сообщениями",
    WSDL: "Описание сервисов и методов",
    "SOAP Envelope": "Структура сообщений",
    "SOAP Header": "Метаданные и безопасность",
    "SOAP Body": "Данные запроса/ответа",
    "RPC vs Document Style": "Стили: RPC или Document",
    "Fault Handling": "Обработка ошибок",
    Authentication: "WS-Security для защиты",
    "Transport Protocols": "HTTP, SMTP, TCP и другие протоколы",
    "Stateful Operations": "Поддержка состояния",
    Interoperability: "Совместимость платформ",
    "Service Binding": "Привязка к протоколам",
    Extensibility: "Расширяемость спецификаций",
    "Message Routing": "Маршрутизация сообщений",
  },
  "API - gRPC - Основные концепции": {
    Определение: "gRPC — высокопроизводительный фреймворк для RPC на Protocol Buffers",
    "Protocol Buffers": "Бинарный формат сериализации данных от Google",
    "Service Definition": "Описание в .proto файлах",
    "Unary RPC": "Обычный запрос-ответ",
    "Server Streaming": "Поток с сервера",
    "Client Streaming": "Поток от клиента",
    "Bidirectional Streaming": "Двусторонний поток",
    Authentication: "TLS для безопасности",
    "Load Balancing": "Балансировка нагрузки",
    "Error Handling": "Коды ошибок gRPC",
    Interceptors: "Обработчики для логирования",
    Reflection: "Упрощенное взаимодействие",
    "Deadline and Timeout": "Тайм-ауты запросов",
    Compression: "Сжатие сообщений",
    "Streaming Flow Control": "Управление потоком",
  },
  "API - ESB - Основные функции": {
    Определение: "ESB — корпоративная шина для централизованной интеграции систем",
    "Service Orchestration": "Координация сервисов",
    "Message Routing": "Маршрутизация сообщений",
    Transformation: "Преобразование данных",
    "Protocol Mediation": "Совместимость протоколов",
    Security: "Защита сообщений",
    "Transaction Management": "Управление транзакциями",
    "Monitoring and Logging": "Мониторинг и логи",
    "Service Registry": "Реестр сервисов",
    "Error Handling": "Обработка ошибок",
    Scalability: "Масштабирование",
    "Integration Adapters": "Адаптеры для систем",
    "Event-Driven Architecture": "Событийность",
    "Policy Enforcement": "Политики доступа",
  },
  "API - Брокеры сообщений - Основные понятия": {
    Определение: "Брокеры — посредники для асинхронного обмена сообщениями между системами",
    "Publish/Subscribe": "Публикация и подписка",
    "Message Queuing": "Очереди сообщений",
    Routing: "Маршрутизация по темам",
    Durability: "Сохранность при сбоях",
    Scalability: "Масштабируемость",
    "High Availability": "Отказоустойчивость",
    "Message Filtering": "Фильтрация сообщений",
    "Dead Letter Queues": "Очереди ошибок",
    "Transactional Messaging": "Транзакционность",
    Security: "Безопасность сообщений",
    "Monitoring and Management": "Управление и мониторинг",
    Integration: "Интеграция через API",
    "Protocol Support": "AMQP, MQTT, STOMP, JMS",
    "Load Balancing": "Балансировка нагрузки",
  },
  "API - Вопросы и Ответы для Собеседований": {
    "Что такое REST и чем он отличается от SOAP?":
      "REST использует HTTP, легче в использовании и более гибкий, SOAP - строгий XML-протокол с встроенной безопасностью",
    "Каковы преимущества gRPC?":
      "Высокая производительность, бинарный протокол, поддержка стриминга",
    "Что такое ESB?":
      "Шина для интеграции систем с маршрутизацией и преобразованием данных",
    "Функции брокера сообщений?":
      "Обмен сообщениями, очереди, маршрутизация, гарантированная доставка",
    "Безопасность в REST API?":
      "OAuth/JWT, HTTPS, CORS, валидация входных данных",
    "Что такое idempotency?": "Свойство операции, при котором повторные запросы дают тот же результат без побочных эффектов",
    "Синхронная vs асинхронная коммуникация?":
      "Синхронная ждет ответа, асинхронная работает без ожидания",
    "Протоколы брокеров сообщений?": "AMQP для enterprise-систем, MQTT для IoT, Kafka Protocol для потоковой обработки",
    "Транзакционность в брокерах?":
      "Механизмы подтверждения и повторов для гарантированной доставки",
    "Service orchestration в ESB?":
      "Координация сервисов через маршрутизацию и преобразование",
    "Мониторинг ESB и брокеров?": "Prometheus, Grafana, встроенные инструменты",
    "Принципы REST?": "Клиент-сервер, stateless, кэширование, единый интерфейс, многоуровневость",
    "HATEOAS?": "Навигация по API через гиперссылки в ответах для обнаружения доступных действий",
    "Unary RPC vs Streaming?": "Одиночный запрос-ответ против потока сообщений",
    "Преимущества Protocol Buffers?":
      "Компактность, производительность, типизация",
    "ESB в интеграции?": "Стандартизирует обмен данными между системами",
    "Dead Letter Queue?": "Очередь для необработанных сообщений",
    "Высокая доступность брокера?":
      "Кластеризация, репликация, автопереключение",
    "Аутентификация в SOAP?": "WS-Security с токенами и подписями",
    "Версионирование REST API?": "Через URL или заголовки",
    "Типы сообщений ESB?": "Синхронные, асинхронные, события, команды",
    "Bidirectional streaming?": "Двусторонний обмен для real-time приложений",
  },
  "API - Примеры": {
    "Создание REST API с использованием Node.js и Express":
      "Пример: `const express = require('express'); const app = express(); app.get('/users', (req, res) => { res.send('User list'); }); app.listen(3000);`",
    "Отправка SOAP-запроса с использованием Python":
      "Пример: `import requests; from requests import Session; from requests.auth import HTTPBasicAuth; wsdl = 'http://example.com/service?wsdl'; response = requests.post(wsdl, data=soap_envelope, headers={'Content-Type': 'text/xml'})`",
    "Определение сервиса gRPC с использованием Protocol Buffers":
      "Пример:\n`syntax = 'proto3';\nservice Greeter {\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\nmessage HelloRequest { string name = 1; }\nmessage HelloReply { string message = 1; }`",
    "Настройка маршрутизации сообщений в ESB MuleSoft":
      "Пример: Создание flow с HTTP Listener, последующей обработкой данных и отправкой в очередь RabbitMQ через соответствующий connector.",
    "Использование RabbitMQ для обмена сообщениями между сервисами":
      "Пример: Отправка сообщения: `channel.basic_publish(exchange='', routing_key='queue_name', body='Hello World')`. Получение сообщения: `method, properties, body = channel.basic_get('queue_name')`",
    "Создание транзакционной очереди в Apache Kafka":
      "Пример: Настройка producer с `enable.idempotence=true` и использование `transactional.id`, а также управление транзакциями через `begin_transaction`, `send_offsets_to_transaction` и `commit_transaction`",
    "Пример аутентификации с использованием JWT в REST API":
      "Пример: Создание middleware в Express, который проверяет наличие и валидность JWT в заголовке Authorization перед обработкой запроса",
    "Интеграция REST API с ESB для обработки бизнес-логики":
      "Пример: REST API вызывает ESB, который маршрутизирует запрос к нескольким микросервисам, агрегирует результаты и возвращает ответ клиенту",
    "Использование gRPC для реализации микросервисной архитектуры":
      "Пример: Один микросервис предоставляет сервис Greeter через gRPC, а другой микросервис вызывает метод SayHello этого сервиса для получения приветствия",
    "Настройка мониторинга брокера сообщений RabbitMQ с помощью Prometheus и Grafana":
      "Пример: Экспорт метрик RabbitMQ через Prometheus Exporter и создание дашборда в Grafana для визуализации производительности и состояния очередей",
    "Создание SOAP-сервиса с использованием Java и Spring Boot":
      "Пример: Определение WSDL файла, создание классов сервисов и конфигурация Spring Boot для обработки SOAP-запросов",
    "Реализация bidirectional streaming в gRPC на Go":
      "Пример: Реализация сервера и клиента, которые обмениваются потоками сообщений через gRPC, используя Go библиотеку",
    "Настройка ESB с использованием Apache Camel для интеграции с Salesforce":
      "Пример: Создание маршрута Camel, который извлекает данные из Salesforce, преобразует их и отправляет в другую систему",
    "Использование Dead Letter Queue в RabbitMQ":
      "Пример: Конфигурация очереди с DLX (Dead Letter Exchange) и настройка обработки неуспешных сообщений",
    "Создание и публикация Protocol Buffer схемы для gRPC сервиса":
      "Пример: Определение .proto файла, генерация кода клиента и сервера с помощью protoc, и публикация схемы в репозитории",
  },
  "API - HTTP Коды состояния": {
    "200 OK": "Успешный запрос",
    "201 Created": "Ресурс успешно создан",
    "202 Accepted": "Запрос принят на обработку",
    "204 No Content": "Успешный запрос без тела ответа",
    "206 Partial Content": "Частичный ответ",
    "300 Multiple Choices": "Несколько вариантов ответа",
    "301 Moved Permanently": "Ресурс перемещен навсегда",
    "302 Found": "Временное перенаправление",
    "303 See Other": "Смотреть другой URI",
    "304 Not Modified": "Контент не изменялся",
    "307 Temporary Redirect": "Временное перенаправление",
    "308 Permanent Redirect": "Постоянное перенаправление",
    "400 Bad Request": "Неправильный запрос от клиента",
    "401 Unauthorized": "Требуется аутентификация",
    "402 Payment Required": "Требуется оплата",
    "403 Forbidden": "Доступ запрещен",
    "404 Not Found": "Ресурс не найден",
    "405 Method Not Allowed": "Метод не поддерживается",
    "406 Not Acceptable": "Неприемлемый запрос",
    "407 Proxy Authentication Required": "Требуется аутентификация прокси",
    "408 Request Timeout": "Таймаут запроса",
    "409 Conflict": "Конфликт версий",
    "410 Gone": "Ресурс удален",
    "411 Length Required": "Требуется заголовок Content-Length",
    "412 Precondition Failed": "Невыполнение условий запроса",
    "413 Payload Too Large": "Слишком большой объем данных",
    "414 URI Too Long": "Слишком длинный URI",
    "415 Unsupported Media Type": "Неподдерживаемый тип данных",
    "416 Range Not Satisfiable": "Невыполнимый диапазон",
    "417 Expectation Failed": "Невыполнимое ожидание",
    "418 I'm a teapot": "Я чайник (RFC 2324)",
    "421 Misdirected Request": "Неправильное направление запроса",
    "422 Unprocessable Entity": "Необрабатываемая сущность",
    "423 Locked": "Ресурс заблокирован",
    "424 Failed Dependency": "Невыполненная зависимость",
    "425 Too Early": "Слишком рано",
    "426 Upgrade Required": "Требуется обновление",
    "428 Precondition Required": "Требуется предварительное условие",
    "429 Too Many Requests": "Превышен лимит запросов",
    "431 Request Header Fields Too Large": "Слишком большие заголовки",
    "451 Unavailable For Legal Reasons": "Недоступно по юридическим причинам",
    "500 Internal Server Error": "Внутренняя ошибка сервера",
    "501 Not Implemented": "Метод не реализован",
    "502 Bad Gateway": "Некорректный ответ от вышестоящего сервера",
    "503 Service Unavailable": "Сервис временно недоступен",
    "504 Gateway Timeout": "Превышен таймаут ожидания ответа от шлюза",
    "505 HTTP Version Not Supported": "Версия HTTP не поддерживается",
    "506 Variant Also Negotiates": "Вариант тоже участвует в согласовании",
    "507 Insufficient Storage": "Недостаточно места",
    "508 Loop Detected": "Обнаружена петля",
    "510 Not Extended": "Не расширено",
    "511 Network Authentication Required": "Требуется сетевая аутентификация"
  },
};
