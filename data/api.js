// api.js
window.Api = {
  "API - REST - Основные концепции": {
    Определение:
      "REST (Representational State Transfer) — архитектурный стиль для разработки веб-сервисов, использующий стандартные HTTP методы и принципы.",
    "GET /resource": "Получить список или отдельный ресурс",
    "POST /resource": "Создать новый ресурс",
    "PUT /resource/{id}": "Полностью обновить существующий ресурс",
    "PATCH /resource/{id}": "Частично обновить существующий ресурс",
    "DELETE /resource/{id}": "Удалить существующий ресурс",
    "Status Codes":
      "Использовать стандартные коды состояния HTTP для обозначения результатов запроса",
    Authentication:
      "Использовать OAuth 2.0 или JWT для аутентификации и авторизации",
    HATEOAS: "Включать гипермедиа ссылки для упрощения навигации по API",
    Versioning:
      "Версионирование API через URL или заголовки для управления изменениями",
    "Rate Limiting":
      "Ограничение количества запросов для предотвращения перегрузки сервера",
    Caching:
      "Использовать заголовки кэширования для улучшения производительности",
    "Content Negotiation":
      "Поддерживать различные форматы данных, такие как JSON и XML",
    "Error Handling":
      "Стандартизированные ответы об ошибках с описанием проблемы",
    "API Documentation": "Документировать API с помощью Swagger или OpenAPI",
  },
  "API - SOAP - Основные концепции": {
    Определение:
      "SOAP (Simple Object Access Protocol) — протокол для обмена структурированными сообщениями в веб-сервисах, использующий XML.",
    WSDL: "Использовать WSDL для описания сервисов и методов",
    "SOAP Envelope": "Структурировать сообщения с помощью SOAP Envelope",
    "SOAP Header":
      "Добавлять метаданные и информацию о безопасности в заголовок SOAP",
    "SOAP Body": "Включать данные запроса и ответа в тело SOAP",
    "RPC vs Document Style": "Выбирать стиль передачи данных: RPC или Document",
    "Fault Handling": "Обрабатывать ошибки с помощью SOAP Fault",
    Authentication: "Использовать WS-Security для аутентификации и шифрования",
    "Transport Protocols":
      "Поддерживать HTTP, SMTP и другие транспортные протоколы",
    "Stateful Operations":
      "Поддерживать состояние между запросами при необходимости",
    Interoperability:
      "Обеспечивать совместимость между различными платформами и языками",
    "Service Binding": "Настраивать привязку сервисов к различным протоколам",
    Extensibility:
      "Расширять функциональность с помощью дополнительных спецификаций SOAP",
    "Message Routing": "Маршрутизировать сообщения между различными сервисами",
  },
  "API - gRPC - Основные концепции": {
    Определение:
      "gRPC — высокопроизводительный фреймворк удалённого вызова процедур, разработанный Google, использующий Protocol Buffers для сериализации данных.",
    "Protocol Buffers": "Использовать Protocol Buffers для сериализации данных",
    "Service Definition": "Определять сервисы и методы с помощью .proto файлов",
    "Unary RPC": "Выполнять стандартные запрос-ответ взаимодействия",
    "Server Streaming": "Получать поток ответов от сервера",
    "Client Streaming": "Отправлять поток запросов на сервер",
    "Bidirectional Streaming":
      "Взаимодействовать в режиме потоковой передачи данных с обоих концов",
    Authentication: "Использовать TLS для безопасности и аутентификации",
    "Load Balancing": "Реализовывать балансировку нагрузки для масштабирования",
    "Error Handling":
      "Использовать коды ошибок gRPC для управления исключениями",
    Interceptors:
      "Добавлять промежуточные обработчики для логирования и мониторинга",
    Reflection:
      "Поддерживать рефлексию для упрощенного взаимодействия клиентов",
    "Deadline and Timeout":
      "Устанавливать сроки выполнения запросов для предотвращения зависаний",
    Compression: "Использовать сжатие для уменьшения размера сообщений",
    "Streaming Flow Control":
      "Управлять потоком данных для оптимизации передачи",
  },
  "API - ESB - Основные функции": {
    Определение:
      "ESB (Enterprise Service Bus) — архитектурный паттерн для интеграции различных систем и сервисов, обеспечивающий маршрутизацию, преобразование данных и управление взаимодействиями.",
    "Service Orchestration":
      "Организовывать и координировать взаимодействие между сервисами",
    "Message Routing":
      "Маршрутизировать сообщения на основе содержимого или правил",
    Transformation:
      "Преобразовывать данные между различными форматами и протоколами",
    "Protocol Mediation":
      "Обеспечивать совместимость между различными транспортными протоколами",
    Security: "Управлять аутентификацией, авторизацией и шифрованием сообщений",
    "Transaction Management":
      "Обрабатывать распределенные транзакции и обеспечивать их целостность",
    "Monitoring and Logging":
      "Отслеживать и записывать активность ESB для анализа и отладки",
    "Service Registry": "Регистрировать и обнаруживать сервисы в экосистеме",
    "Error Handling":
      "Обрабатывать ошибки и обеспечивать надежность передачи сообщений",
    Scalability: "Масштабировать ESB для обработки большого объема сообщений",
    "Integration Adapters":
      "Использовать адаптеры для интеграции с различными системами и приложениями",
    "Event-Driven Architecture":
      "Поддерживать событийно-ориентированную архитектуру для асинхронного взаимодействия",
    "Policy Enforcement":
      "Применять политики управления и контроля доступа к сервисам",
  },
  "API - Брокеры сообщений - Основные понятия": {
    Определение:
      "Брокеры сообщений — это посредники, обеспечивающие обмен сообщениями между различными компонентами системы, поддерживая асинхронную коммуникацию и гарантированную доставку.",
    "Publish/Subscribe":
      "Реализовывать модель публикации и подписки для распределения сообщений",
    "Message Queuing":
      "Обеспечивать очереди сообщений для асинхронной обработки",
    Routing: "Маршрутизировать сообщения на основе тем или заголовков",
    Durability: "Гарантировать сохранность сообщений при сбоях системы",
    Scalability:
      "Масштабировать брокер для обработки большого объема сообщений",
    "High Availability":
      "Обеспечивать отказоустойчивость и высокую доступность брокера",
    "Message Filtering": "Фильтровать сообщения для целевых подписчиков",
    "Dead Letter Queues":
      "Обрабатывать неуспешные сообщения в специальных очередях",
    "Transactional Messaging":
      "Поддерживать транзакции для гарантированной доставки сообщений",
    Security:
      "Обеспечивать безопасность сообщений через шифрование и аутентификацию",
    "Monitoring and Management":
      "Отслеживать состояние брокера и управлять им через панели мониторинга",
    Integration:
      "Интегрироваться с различными системами и сервисами через API и адаптеры",
    "Protocol Support":
      "Поддерживать различные протоколы передачи сообщений, такие как AMQP, MQTT, и STOMP",
    "Load Balancing":
      "Распределять нагрузку между несколькими брокерами для повышения производительности",
  },
  "API - Вопросы и Ответы для Собеседований": {
    "Что такое REST и чем он отличается от SOAP?":
      "REST — это архитектурный стиль для построения веб-сервисов, использующий HTTP методы. SOAP — протокол для обмена структурированными сообщениями, использующий XML. REST более легковесен и гибок, тогда как SOAP предоставляет встроенную поддержку безопасности и транзакций.",
    "Каковы преимущества использования gRPC?":
      "gRPC обеспечивает высокую производительность благодаря бинарной сериализации, поддерживает различные языки программирования, предоставляет возможности стриминга и интеграции с Protocol Buffers.",
    "Что такое ESB и зачем он нужен?":
      "ESB (Enterprise Service Bus) — это архитектурный паттерн для интеграции различных систем и сервисов, обеспечивающий маршрутизацию, преобразование данных, управление транзакциями и безопасность.",
    "Какие основные функции выполняет брокер сообщений?":
      "Брокер сообщений обеспечивает обмен сообщениями между различными компонентами системы, поддерживает очереди сообщений, маршрутизацию, гарантированную доставку, масштабируемость и отказоустойчивость.",
    "Как реализовать безопасность в REST API?":
      "Использовать аутентификацию и авторизацию, такие как OAuth 2.0 или JWT, применять HTTPS для шифрования данных, ограничивать доступ с помощью CORS и внедрять механизмы защиты от атак, таких как rate limiting и input validation.",
    "Объясните понятие idempotency в контексте REST API":
      "Idempotency означает, что повторное выполнение одного и того же запроса приводит к тому же результату, что и однократное выполнение, что важно для обеспечения надежности и предсказуемости API.",
    "Чем отличается synchronous от asynchronous коммуникация в ESB?":
      "Synchronous коммуникация требует ожидания ответа от получателя, тогда как asynchronous позволяет отправителю продолжить работу без ожидания ответа, что повышает масштабируемость и производительность.",
    "Какие протоколы поддерживают брокеры сообщений и когда их использовать?":
      "Брокеры сообщений могут поддерживать AMQP, MQTT, STOMP и другие. Выбор протокола зависит от требований к производительности, надежности и специфики приложения, например, MQTT часто используется в IoT, а AMQP — в корпоративных системах.",
    "Как обеспечивается транзакционность в брокерах сообщений?":
      "Используя механизмы подтверждения доставки, повторных попыток и распределенных транзакций, которые гарантируют, что сообщения обрабатываются точно один раз и в правильном порядке.",
    "Что такое service orchestration и как она реализуется в ESB?":
      "Service orchestration — это координация нескольких сервисов для выполнения бизнес-процесса. В ESB это достигается через маршрутизацию, преобразование данных и управление вызовами сервисов.",
    "Какие инструменты мониторинга вы использовали для ESB и брокеров сообщений?":
      "Примеры включают Prometheus, Grafana, Kibana, встроенные панели мониторинга ESB решений, таких как MuleSoft или Apache Camel, и специализированные инструменты для брокеров сообщений, такие как RabbitMQ Management UI или Kafka Manager.",
    "Каковы основные принципы REST архитектуры?":
      "Основные принципы включают клиент-серверную архитектуру, отсутствие состояния (stateless), кэшируемость, единый интерфейс и многоуровневую систему.",
    "Что такое HATEOAS и зачем оно нужно?":
      "HATEOAS (Hypermedia as the Engine of Application State) позволяет клиентам динамически взаимодействовать с API, используя гипермедиа ссылки, предоставленные сервером.",
    "В чем разница между Unary RPC и Streaming в gRPC?":
      "Unary RPC — стандартный запрос-ответ, где клиент отправляет один запрос и получает один ответ. Streaming позволяет обмениваться потоками сообщений, поддерживая серверный, клиентский или двунаправленный стриминг.",
    "Какие преимущества предоставляет использование Protocol Buffers в gRPC?":
      "Protocol Buffers обеспечивают компактную бинарную сериализацию, высокую производительность, поддержку множества языков программирования и легкость в определении схем данных.",
    "Как ESB помогает в интеграции различных систем?":
      "ESB обеспечивает стандартизированный механизм обмена сообщениями, маршрутизацию, трансформацию данных и управление взаимодействиями, что упрощает интеграцию различных систем и сервисов.",
    "Что такое Dead Letter Queue и для чего она используется?":
      "Dead Letter Queue — специальная очередь для сообщений, которые не удалось обработать, что позволяет анализировать и повторно обрабатывать такие сообщения без влияния на основную систему.",
    "Как обеспечить высокую доступность брокера сообщений?":
      "Использовать кластеризацию, репликацию сообщений, автоматическое переключение при сбоях и балансировку нагрузки между несколькими брокерами.",
    "Какие существуют методы аутентификации в SOAP сервисах?":
      "Использование WS-Security, включая токены, цифровые подписи и шифрование, для обеспечения аутентификации и безопасности сообщений.",
    "Как реализовать versioning в REST API?":
      "Через версии в URL (например, /v1/resource) или через заголовки (например, X-API-Version), позволяя управлять изменениями и совместимостью API.",
    "Какие типы сообщений поддерживает ESB?":
      "ESB поддерживает синхронные и асинхронные сообщения, события, запросы-ответы, команды и другие типы взаимодействий в зависимости от потребностей бизнеса.",
    "Что такое bidirectional streaming в gRPC и когда его использовать?":
      "Bidirectional streaming позволяет одновременно отправлять и получать поток сообщений, что полезно для чатов, обмена данными в реальном времени и других интерактивных приложений.",
  },
  "API - Примеры": {
    "Создание REST API с использованием Node.js и Express":
      "Пример: `const express = require('express'); const app = express(); app.get('/users', (req, res) => { res.send('User list'); }); app.listen(3000);`",
    "Отправка SOAP-запроса с использованием Python":
      "Пример: `import requests; from requests import Session; from requests.auth import HTTPBasicAuth; wsdl = 'http://example.com/service?wsdl'; response = requests.post(wsdl, data=soap_envelope, headers={'Content-Type': 'text/xml'})`",
    "Определение сервиса gRPC с использованием Protocol Buffers":
      "Пример:\n`syntax = 'proto3';\nservice Greeter {\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\nmessage HelloRequest { string name = 1; }\nmessage HelloReply { string message = 1; }`",
    "Настройка маршрутизации сообщений в ESB MuleSoft":
      "Пример: Создание flow с HTTP Listener, последующей обработкой данных и отправкой в очередь RabbitMQ через соответствующий connector.",
    "Использование RabbitMQ для обмена сообщениями между сервисами":
      "Пример: Отправка сообщения: `channel.basic_publish(exchange='', routing_key='queue_name', body='Hello World')`. Получение сообщения: `method, properties, body = channel.basic_get('queue_name')`",
    "Создание транзакционной очереди в Apache Kafka":
      "Пример: Настройка producer с `enable.idempotence=true` и использование `transactional.id`, а также управление транзакциями через `begin_transaction`, `send_offsets_to_transaction` и `commit_transaction`",
    "Пример аутентификации с использованием JWT в REST API":
      "Пример: Создание middleware в Express, который проверяет наличие и валидность JWT в заголовке Authorization перед обработкой запроса",
    "Интеграция REST API с ESB для обработки бизнес-логики":
      "Пример: REST API вызывает ESB, который маршрутизирует запрос к нескольким микросервисам, агрегирует результаты и возвращает ответ клиенту",
    "Использование gRPC для реализации микросервисной архитектуры":
      "Пример: Один микросервис предоставляет сервис Greeter через gRPC, а другой микросервис вызывает метод SayHello этого сервиса для получения приветствия",
    "Настройка мониторинга брокера сообщений RabbitMQ с помощью Prometheus и Grafana":
      "Пример: Экспорт метрик RabbitMQ через Prometheus Exporter и создание дашборда в Grafana для визуализации производительности и состояния очередей",
    "Создание SOAP-сервиса с использованием Java и Spring Boot":
      "Пример: Определение WSDL файла, создание классов сервисов и конфигурация Spring Boot для обработки SOAP-запросов",
    "Реализация bidirectional streaming в gRPC на Go":
      "Пример: Реализация сервера и клиента, которые обмениваются потоками сообщений через gRPC, используя Go библиотеку",
    "Настройка ESB с использованием Apache Camel для интеграции с Salesforce":
      "Пример: Создание маршрута Camel, который извлекает данные из Salesforce, преобразует их и отправляет в другую систему",
    "Использование Dead Letter Queue в RabbitMQ":
      "Пример: Конфигурация очереди с DLX (Dead Letter Exchange) и настройка обработки неуспешных сообщений",
    "Создание и публикация Protocol Buffer схемы для gRPC сервиса":
      "Пример: Определение .proto файла, генерация кода клиента и сервера с помощью protoc, и публикация схемы в репозитории",
  },
};
