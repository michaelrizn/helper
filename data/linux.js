// linux.js
window.Linux = {
  "Linux - Основные операции с файлами": {
    Определение:
      "Основные команды для управления файлами и каталогами в Linux, позволяющие создавать, копировать, перемещать, удалять и просматривать файлы.",
    "ls -lh":
      "Показать права доступа к файлам, размер, владельца и т.д. в удобочитаемом формате.",
    "ls -lah":
      "Показать все содержимое каталога, включая скрытые файлы, с подробной информацией.",
    "touch file":
      "Создать пустой файл или обновить временную метку существующего файла.",
    "cp file1 file2": "Копировать file1 в file2. file2 может быть каталогом.",
    "cp -r dir1 dir2": "Рекурсивно копировать dir1 и его содержимое в dir2.",
    "mv file dir": "Переместить файл в каталог.",
    "mv file1 file2": "Переименовать file1 в file2.",
    "rm file": "Удалить файл.",
    "rm -rf dir":
      "Удалить каталог и его содержимое рекурсивно без подтверждения.",
    "mkdir data": "Создать каталог 'data'.",
    pwd: "Показать текущий рабочий каталог.",
    "stat file": "Показать атрибуты файлов и каталогов.",
    "wc file": "Подсчитать байты, слова, строки в файле или стандартном вводе.",
    "file file": "Определить тип файла.",
    "type cd":
      "Узнать, является ли 'cd' встроенной, псевдонимом или внешней командой.",
    "find /path -name 'filename'": "Найти файлы по имени в указанном пути.",
    "ln -s target link":
      "Создать символическую ссылку на целевой файл или каталог.",
    "chmod +x script.sh": "Добавить права на выполнение для файла script.sh.",
    "chown user:group file": "Сменить владельца и группу файла.",
  },
  "Linux - Навигация по каталогам": {
    Определение:
      "Команды для перемещения по файловой системе, перехода между каталогами и управления текущим рабочим каталогом.",
    "cd или cd ~": "Перейти в домашний каталог пользователя.",
    "cd ..": "Перейти в родительский каталог.",
    "cd -": "Переключиться на предыдущий рабочий каталог.",
    "cd /": "Перейти в корневой каталог.",
    "cd /tmp": "Сменить текущий каталог на /tmp.",
    "pushd /path": "Добавить каталог в стек и перейти в него.",
    popd: "Удалить каталог из стека и перейти обратно.",
    "ls -la":
      "Показать подробное содержимое текущего каталога, включая скрытые файлы.",
  },
  "Linux - Управление процессами": {
    Определение:
      "Команды для просмотра, управления и контроля запущенных процессов в системе.",
    ps: "Показать список запущенных процессов.",
    "ps aux":
      "Показать все процессы всех пользователей с подробной информацией.",
    top: "Показать процессы и их использование ресурсов в режиме реального времени.",
    htop: "Интерактивный мониторинг процессов с улучшенным интерфейсом.",
    "btop++": "Графический монитор процессов с дополнительными функциями.",
    bottom: "Кроссплатформенный монитор системы и процессов.",
    glances: "Мониторинг процессов с веб-интерфейсом.",
    gtop: "Графический мониторинг системы для терминала.",
    proc: "Замена htop на языке Rust.",
    pstree: "Показать дерево процессов.",
    "pgrep firefox": "Найти ID процесса firefox.",
    "kill 6732": "Завершить процесс с PID 6732.",
    "killall firefox": "Завершить все процессы firefox.",
    "pkill firefox": "Завершить процессы firefox.",
    bg: "Возобновить приостановленное задание в фоне.",
    fg: "Возобновить приостановленное задание на переднем плане.",
    jobs: "Показать активные задания в текущей оболочке.",
    nice: "Установить приоритет выполнения процесса.",
    renice: "Изменить приоритет уже запущенного процесса.",
    nohup:
      "Запустить процесс, который продолжит выполнение после закрытия терминала.",
    screen: "Управление множеством терминальных сессий.",
    tmux: "Терминальный мультиплексор для управления несколькими сессиями.",
    systemctl: "Управление системой и службами.",
    "ps aux | grep [имя процесса]":
      "Найти процессы по имени с помощью ps и grep.",
    "pgrep имя_процесса": "Найти ID процессов по имени с помощью pgrep.",
    "pidof имя_программы":
      "Получить ID процессов по имени программы с помощью pidof.",
    "kill -9 PID": "Принудительно завершить процесс с указанным PID.",
    "pkill -SIGTERM имя_процесса":
      "Отправить сигнал SIGTERM процессам с указанным именем.",
  },
  "Linux - IPTABLES команды": {
    Определение:
      "Команды для управления брандмауэром iptables, настройки правил фильтрации и маршрутизации трафика.",
    "iptables -L": "Список всех правил в текущей таблице.",
    "iptables -L -v -n":
      "Список правил с подробной информацией и числовыми адресами.",
    "iptables -S":
      "Список всех правил в формате, который можно использовать повторно.",
    "iptables -F": "Очистить все правила в текущей таблице.",
    "iptables -P INPUT ACCEPT": "Установить политику INPUT chain как ACCEPT.",
    "iptables -A INPUT -p tcp --dport <port> -j ACCEPT":
      "Разрешить входящий трафик на конкретный порт.",
    "iptables -A INPUT -s <ip> -j DROP":
      "Заблокировать трафик с указанного IP.",
    "iptables-save > /etc/iptables/rules.v4": "Сохранить правила IPv4 в файл.",
    "iptables-restore < /etc/iptables/rules.v4":
      "Восстановить правила IPv4 из файла.",
    "iptables -t nat -A POSTROUTING -o <interface> -j MASQUERADE":
      "Включить NAT на интерфейсе.",
    "iptables -t nat -A PREROUTING -p tcp --dport <port> -j REDIRECT --to-port <port>":
      "Перенаправление портов.",
    "iptables -A INPUT -p tcp -m multiport --dports 8000:8080 -j ACCEPT":
      "Разрешить входящий трафик для диапазона портов.",
    "iptables -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT":
      "Разрешить связанные и установленные соединения.",
    "iptables -A INPUT -i lo -j ACCEPT":
      "Разрешить трафик на loopback интерфейсе.",
    "iptables -A INPUT -p icmp -j ACCEPT":
      "Разрешить ICMP пакеты (например, ping).",
  },
  "Linux - grep команды": {
    Определение:
      "Команды для поиска текста в файлах или выводе других команд, используя регулярные выражения.",
    "grep 'строка' file": "Найти строку в файле.",
    "grep -r 'строка' dir": "Рекурсивный поиск строки в каталоге.",
    "grep -i 'строка' file": "Поиск строки без учета регистра.",
    "grep -v 'строка' file": "Вывод строк, не содержащих указанную строку.",
    "grep -n 'строка' file": "Показать номер строки с совпадением.",
    "grep -l 'строка' dir/*": "Вывести список файлов, содержащих строку.",
    "grep -c 'строка' file": "Подсчитать количество совпадений.",
    "grep -E 'regex' file": "Использовать расширенные регулярные выражения.",
    "grep -A 2 'строка' file": "Показать 2 строки после совпадения.",
    "grep -B 2 'строка' file": "Показать 2 строки до совпадения.",
    "grep -C 2 'строка' file": "Показать 2 строки до и после совпадения.",
    "grep -r -E 'regex' dir":
      "Рекурсивный поиск с использованием расширенных регулярных выражений.",
    "grep --color=auto 'строка' file":
      "Выделить найденную строку цветом в выводе.",
    "grep -w 'слово' file": "Найти точное совпадение слова.",
    "grep -F 'строка' file":
      "Использовать фиксированные строки вместо регулярных выражений.",
  },
  "Linux - Управление пакетами": {
    Определение:
      "Команды для установки, обновления, удаления и поиска программных пакетов в системе.",
    "apt update": "Обновить список доступных пакетов и их версий.",
    "apt upgrade": "Установить последние версии всех установленных пакетов.",
    "apt install package": "Установить указанный пакет.",
    "apt remove package": "Удалить указанный пакет.",
    "apt purge package":
      "Полностью удалить пакет вместе с его конфигурационными файлами.",
    "apt autoremove":
      "Удалить пакеты, установленные автоматически и больше не нужные.",
    "apt search package": "Поиск пакета в репозиториях.",
    "dpkg -i package.deb": "Установить пакет из .deb файла.",
    "dpkg -r package": "Удалить установленный пакет.",
    "yum update": "Обновить все установленные пакеты до последних версий.",
    "yum install package": "Установить указанный пакет.",
    "yum remove package": "Удалить указанный пакет.",
    "yum search package": "Поиск пакета в репозиториях.",
    "dnf update":
      "Обновить все установленные пакеты до последних версий (для Fedora).",
    "dnf install package": "Установить указанный пакет (для Fedora).",
    "dnf remove package": "Удалить указанный пакет (для Fedora).",
    "snap install package": "Установить пакет через Snap.",
    "flatpak install repository package": "Установить пакет через Flatpak.",
    "apt-cache policy package":
      "Показать информацию о пакете, включая доступные версии.",
    "apt-get dist-upgrade":
      "Выполнить расширенное обновление системы, включая удаление пакетов.",
    "yum groupinstall 'Group Name'": "Установить группу пакетов.",
    "dnf groupupgrade 'Group Name'": "Обновить группу пакетов.",
  },
  "Linux - Управление дисками": {
    Определение:
      "Команды для управления дисковыми устройствами, разделами, файловыми системами и монтированием.",
    "df -h":
      "Показать использование дискового пространства файловой системой в удобочитаемом формате.",
    "du -sh /path/to/directory":
      "Оценить использование пространства в каталоге /path/to/directory.",
    "ncdu /path/to/directory":
      "Интерактивный просмотр использования диска в каталоге /path/to/directory.",
    lsblk:
      "Отобразить список всех доступных блочных устройств вместе с их разделами и монтированными точками.",
    "fdisk -l": "Показать доступные разделы на диске.",
    "mkfs /dev/sda1": "Создать файловую систему на разделе /dev/sda1.",
    "mount /dev/sda1 /mnt": "Примонтировать раздел /dev/sda1 к каталогу /mnt.",
    "umount /mnt": "Отмонтировать раздел, примонтированный в каталоге /mnt.",
    "fsck /dev/sda": "Проверить раздел диска на ошибки.",
    "parted /dev/sda": "Управление разделами диска с помощью parted.",
    blkid: "Показать идентификаторы блочных устройств.",
    "mkfs.ext4 /dev/sda1":
      "Создать файловую систему ext4 на разделе /dev/sda1.",
    "resize2fs /dev/sda1":
      "Изменить размер файловой системы на разделе /dev/sda1.",
    "mount -a": "Примонтировать все файловые системы, указанные в /etc/fstab.",
    "ls -l /dev/disk/by-uuid/": "Показать UUID блочных устройств.",
  },
  "Linux - Управление памятью": {
    Определение:
      "Команды для мониторинга и управления использованием оперативной памяти и свопа в системе.",
    "free -h":
      "Показать количество свободной и используемой памяти в удобочитаемом формате.",
    htop: "Интерактивный монитор ресурсов с детальной информацией о памяти.",
    "vmstat -s": "Показать статистику использования памяти.",
    top: "Показать процессы и использование памяти в режиме реального времени.",
    smem: "Отображает потребление памяти каждым процессом.",
    "watch -n 1 free -h":
      "Наблюдать за использованием памяти каждые 1 секунду.",
    "pmap PID": "Показать использование памяти конкретным процессом.",
    "sar -r 1 3":
      "Отображать использование памяти с интервалом 1 секунда три раза.",
    "dmesg | grep -i memory": "Показать сообщения ядра, связанные с памятью.",
    "sync; echo 3 > /proc/sys/vm/drop_caches":
      "Очистить кэш страниц, dentries и inodes.",
    "swapoff -a": "Отключить использование свопа.",
    "swapon -a": "Включить использование свопа.",
  },
  "Linux - Сетевые команды": {
    Определение:
      "Команды для настройки, диагностики и мониторинга сетевых соединений и интерфейсов в системе.",
    "ping [адрес сервера]": "Проверить доступность сервера с помощью ping.",
    "traceroute [адрес сервера]":
      "Показать путь, который проходят пакеты до сервера.",
    "telnet [адрес] [порт]":
      "Проверить доступность определённого порта на сервере с помощью telnet.",
    "ssh [адрес сервера] -p [порт]":
      "Подключиться к серверу через SSH на указанном порту.",
    "nmap -p [порт] [адрес]":
      "Сканировать указанный порт на сервере с помощью nmap.",
    "nc -zv [адрес] [порт]":
      "Проверить открытность порта на сервере с помощью netcat.",
    "ss -tuln | grep [порт]":
      "Проверить, слушает ли система указанный порт с помощью ss.",
    "netstat -an | grep [порт]":
      "Проверить активность указанного порта с помощью netstat.",
    "systemctl list-timers":
      "Просмотреть все таймеры systemd для запланированных задач.",
    ifconfig: "Показать или настроить сетевые интерфейсы (устаревшая).",
    "ip addr": "Показать адреса всех сетевых интерфейсов.",
    "ip link": "Показать состояние всех сетевых интерфейсов.",
    "ip route": "Показать таблицу маршрутизации.",
    iwconfig: "Настроить беспроводные сетевые интерфейсы.",
    "ethtool eth0": "Показать и изменить настройки сетевого интерфейса eth0.",
    "tcpdump -i eth0":
      "Перехватывать и анализировать пакеты на интерфейсе eth0.",
    "wget [URL]": "Скачать файл по URL.",
    "curl -O [URL]": "Скачать файл по URL с сохранением оригинального имени.",
    "scp file user@host:/path":
      "Копировать файл на удалённый сервер с помощью scp.",
    "rsync -avz /source /destination":
      "Синхронизировать файлы между источником и назначением.",
  },
  "Linux - Пользователи и группы": {
    Определение:
      "Команды для управления пользователями и группами, включая добавление, удаление, модификацию и управление правами доступа.",
    "adduser username": "Добавить нового пользователя.",
    "userdel username": "Удалить пользователя.",
    "usermod -aG group username": "Добавить пользователя в группу.",
    "groupadd groupname": "Создать новую группу.",
    "groupdel groupname": "Удалить группу.",
    "passwd username": "Изменить пароль пользователя.",
    "id username": "Показать информацию о пользователе.",
    whoami: "Показать текущего пользователя.",
    "su - username": "Переключиться на другого пользователя.",
    "sudo command": "Выполнить команду с правами суперпользователя.",
    "newgrp groupname": "Переключиться на другую группу в текущей сессии.",
    "chage -l username":
      "Показать информацию о сроке действия пароля пользователя.",
    "getent passwd": "Показать список всех пользователей в системе.",
    "getent group": "Показать список всех групп в системе.",
    "usermod -d /new/home username": "Изменить домашний каталог пользователя.",
    "useradd -m -s /bin/bash username":
      "Добавить нового пользователя с созданием домашнего каталога и оболочки bash.",
  },
  "Linux - Управление правами доступа": {
    Определение:
      "Команды для управления правами доступа к файлам и каталогам, включая изменение прав и владельцев.",
    "chmod 755 script.sh": "Установить права выполнения файла script.sh.",
    "chmod u+s script.sh": "Установить SUID для файла script.sh.",
    "chmod g+s dir": "Установить SGID для каталога dir.",
    "chmod +t dir": "Установить Sticky Bit для каталога dir.",
    "chown user file.txt": "Сменить владельца file.txt на user.",
    "chgrp group file.txt": "Сменить группу file.txt на group.",
    "umask 022": "Установить права доступа по умолчанию для новых файлов.",
    "getfacl file": "Показать ACL права файла или каталога.",
    "setfacl -m u:traw:rwx file":
      "Установить права доступа ACL для пользователя traw.",
    "setfacl -x u:devops file":
      "Удалить права доступа ACL для пользователя devops.",
    "chmod +w файл":
      "Добавить права на запись для файла, позволяя его редактировать.",
    "chmod 777 файл":
      "Установить полные права (чтение, запись, выполнение) для всех.",
    "chmod 755 файл":
      "Установить права на чтение, запись и выполнение для владельца; чтение и выполнение для группы и остальных.",
    "chmod 644 файл":
      "Установить права на чтение и запись для владельца; только чтение для группы и остальных.",
    "chmod -R 755 папка":
      "Рекурсивно установить права чтения, записи и выполнения для владельца, и чтения и выполнения для группы и остальных, применённо ко всем файлам и директориям внутри папки.",
    "chmod -w файл": "Удалить права на запись у файла.",
    "chattr +i file":
      "Установить атрибут 'immutable' для файла, запрещая его изменение.",
    "chattr -i file": "Снять атрибут 'immutable' с файла.",
  },
  "Linux - Управление печатью": {
    Определение:
      "Команды для управления выводом данных в терминал или другие устройства вывода.",
    "echo 'Hello World'": "Вывести текст 'Hello World' в стандартный вывод.",
    "seq 1 5": "Вывести последовательность чисел от 1 до 5.",
    clear: "Очистить экран терминала.",
    "printf 'Name: %s, Age: %d\\n' John 30":
      "Отформатировать и вывести строку с переменными.",
    "yes 'continue'": "Постоянно выводить 'continue' до прерывания.",
    "cat file": "Вывести содержимое файла на стандартный вывод.",
    "tac file": "Вывести содержимое файла в обратном порядке.",
    "nl file": "Нумеровать строки файла при выводе.",
    "head -n 10 file": "Показать первые 10 строк файла.",
    "tail -n 10 file": "Показать последние 10 строк файла.",
    "tail -f /var/log/syslog":
      "Отслеживать изменения в файле в реальном времени.",
    "less file": "Просмотреть содержимое файла постранично.",
    "more file":
      "Просмотреть содержимое файла постранично (менее функционально, чем less).",
    "wc -l file": "Подсчитать количество строк в файле.",
    "diff file1 file2": "Показать различия между двумя файлами.",
    "sort file": "Отсортировать строки файла.",
    "uniq file":
      "Удалить повторяющиеся строки в файле (предварительно отсортированный).",
  },
  "Linux - Cron Job примеры": {
    Определение:
      "Примеры cron-заданий для автоматизации выполнения команд и скриптов по расписанию.",
    "0 0 * * * команда": "Выполнение команды каждый день в полночь.",
    "0 1 * * 1 команда": "Выполнение команды каждый понедельник в 01:00.",
    "*/5 * * * * команда": "Выполнение команды каждые 5 минут.",
    "0 5 * * * команда": "Выполнение команды каждый день в 05:00 утра.",
    "@reboot команда": "Выполнение команды после каждой перезагрузки системы.",
    "@hourly команда": "Выполнение команды каждый час.",
    "@daily команда": "Выполнение команды каждый день.",
    "@weekly команда": "Выполнение команды каждую неделю.",
    "@monthly команда": "Выполнение команды каждый месяц.",
    "@yearly команда": "Выполнение команды каждый год.",
    "30 2 * * 7 команда":
      "Выполнение команды каждую неделю в воскресенье в 02:30.",
    "15 10 * * 1-5 команда":
      "Выполнение команды с понедельника по пятницу в 10:15.",
    "0 */6 * * * команда": "Выполнение команды каждые 6 часов.",
    "0 22 * * 1 команда": "Выполнение команды каждый понедельник в 22:00.",
    "0 0 1 * * команда":
      "Выполнение команды первого числа каждого месяца в полночь.",
  },
  "Linux - Вопросы и Ответы для Собеседований": {
    "Какова разница между `chmod 755` и `chmod 644`?":
      "Команда `chmod 755` устанавливает права чтения, записи и выполнения для владельца, и только чтение и выполнение для группы и остальных. `chmod 644` устанавливает права чтения и записи для владельца и только чтение для группы и остальных.",
    "Что такое SUID и SGID?":
      "SUID (Set User ID) позволяет пользователям запускать файл с правами владельца файла. SGID (Set Group ID) позволяет пользователям запускать файл с правами группы файла.",
    "Как проверить, открыт ли определённый порт на сервере?":
      "Используйте команды `telnet <адрес> <порт>`, `nmap -p <порт> <адрес>`, или `nc -zv <адрес> <порт>`.",
    "Что делает команда `ps aux`?":
      "Команда `ps aux` отображает список всех запущенных процессов во всей системе с подробной информацией.",
    "Как найти и удалить временные файлы, занимающие много места?":
      "Используйте `find /tmp -type f -size +100M` для поиска больших файлов и `rm` для их удаления.",
    "Объясните разницу между `kill`, `pkill` и `killall`":
      "`kill` отправляет сигнал процессу по PID, `pkill` отправляет сигнал процессам по имени, `killall` отправляет сигнал всем процессам с указанным именем.",
    "Как настроить cron задачу для выполнения скрипта каждую ночь в 2 часа?":
      "Добавьте строку `0 2 * * * /path/to/script.sh` в crontab с помощью `crontab -e`.",
    "Что происходит, когда вы используете `sudo !!`?":
      "`sudo !!` повторяет последнюю выполненную команду с правами суперпользователя.",
    "Как посмотреть, какие команды были выполнены в текущей сессии?":
      "Используйте команду `history`.",
    "Как изменить приоритет процесса?":
      "Используйте команду `nice` для запуска процесса с новым приоритетом или `renice` для изменения приоритета уже запущенного процесса.",
    "Что делает команда `tar -czvf archive.tar.gz /path/to/directory`?":
      "Создает сжатый архив `archive.tar.gz` из указанного каталога.",
    "Как проверить целостность файловой системы?":
      "Используйте команду `fsck /dev/sda1` для проверки файловой системы на разделе `/dev/sda1`.",
    "Как создать символическую ссылку и что она делает?":
      "Используйте команду `ln -s /path/to/target /path/to/link`. Она создаёт ссылку, которая указывает на целевой файл или каталог.",
    "Как установить определённый пакет и его зависимости?":
      "Используйте `sudo apt install package-name` для установки пакета и автоматически его зависимостей.",
    "Как просмотреть использование дискового пространства по каталогам?":
      "Используйте команду `du -sh /path/to/directory` для оценки использования пространства в указанном каталоге.",
    "Что такое `nohup` и для чего он используется?":
      "`nohup` используется для запуска процесса, который продолжит выполняться после закрытия терминала.",
    "Какова разница между `ps` и `top`?":
      "`ps` показывает статичный снимок процессов в момент выполнения команды, тогда как `top` предоставляет динамический, обновляемый в реальном времени монитор процессов.",
    "Как изменить владельца и группу файла?":
      "Используйте `chown user:group file` для изменения владельца и группы файла.",
    "Что такое sticky bit и для чего он используется?":
      "Sticky bit предотвращает удаление или переименование файлов в каталоге другими пользователями, кроме владельца файла или суперпользователя.",
    "Как проверить, какой пользователь запустил процесс?":
      "Используйте `ps -o user= -p PID` для отображения пользователя, запустившего процесс с указанным PID.",
    "Какие основные принципы REST архитектуры?":
      "Основные принципы включают клиент-серверную архитектуру, отсутствие состояния (stateless), кэшируемость, единый интерфейс и многоуровневую систему.",
    "Что такое HATEOAS и зачем оно нужно?":
      "HATEOAS (Hypermedia as the Engine of Application State) позволяет клиентам динамически взаимодействовать с API, используя гипермедиа ссылки, предоставленные сервером.",
    "В чем разница между Unary RPC и Streaming в gRPC?":
      "Unary RPC — стандартный запрос-ответ, где клиент отправляет один запрос и получает один ответ. Streaming позволяет обмениваться потоками сообщений, поддерживая серверный, клиентский или двунаправленный стриминг.",
    "Какие преимущества предоставляет использование Protocol Buffers в gRPC?":
      "Protocol Buffers обеспечивают компактную бинарную сериализацию, высокую производительность, поддержку множества языков программирования и легкость в определении схем данных.",
    "Как ESB помогает в интеграции различных систем?":
      "ESB обеспечивает стандартизированный механизм обмена сообщениями, маршрутизацию, трансформацию данных и управление взаимодействиями, что упрощает интеграцию различных систем и сервисов.",
    "Что такое Dead Letter Queue и для чего она используется?":
      "Dead Letter Queue — специальная очередь для сообщений, которые не удалось обработать, что позволяет анализировать и повторно обрабатывать такие сообщения без влияния на основную систему.",
    "Как обеспечить высокую доступность брокера сообщений?":
      "Использовать кластеризацию, репликацию сообщений, автоматическое переключение при сбоях и балансировку нагрузки между несколькими брокерами.",
    "Какие существуют методы аутентификации в SOAP сервисах?":
      "Использование WS-Security, включая токены, цифровые подписи и шифрование, для обеспечения аутентификации и безопасности сообщений.",
    "Как реализовать versioning в REST API?":
      "Через версии в URL (например, /v1/resource) или через заголовки (например, X-API-Version), позволяя управлять изменениями и совместимостью API.",
    "Какие типы сообщений поддерживает ESB?":
      "ESB поддерживает синхронные и асинхронные сообщения, события, запросы-ответы, команды и другие типы взаимодействий в зависимости от потребностей бизнеса.",
    "Что такое bidirectional streaming в gRPC и когда его использовать?":
      "Bidirectional streaming позволяет одновременно отправлять и получать поток сообщений, что полезно для чатов, обмена данными в реальном времени и других интерактивных приложений.",
    "Чем YAML отличается от JSON?":
      "YAML более читаем для человека и поддерживает сложные структуры данных, такие как ссылки и алиасы, тогда как JSON проще и чаще используется для обмена данными между клиентом и сервером.",
    "Когда лучше использовать MessagePack вместо JSON?":
      "MessagePack лучше использовать, когда важна компактность данных и высокая скорость сериализации/десериализации, например, в мобильных приложениях и IoT устройствах.",
    "Что такое Protocol Buffers и как они используются в gRPC?":
      "Protocol Buffers — это метод сериализации структурированных данных, используемый в gRPC для определения сервисов и методов через .proto файлы, обеспечивая эффективную передачу данных между клиентом и сервером.",
    "Как обеспечить безопасность данных при использовании YAML?":
      "Использовать ограниченные парсеры, избегать выполнения произвольного кода при парсинге, валидировать входные данные и применять механизмы аутентификации и авторизации.",
  },
  "Linux - Примеры": {
    "Копирование директории рекурсивно":
      "Команда: `cp -r /source/directory /destination/directory`",
    "Поиск строк в файле, не учитывая регистр":
      "Команда: `grep -i 'search_term' file.txt`",
    "Удаление всех файлов с расширением .log": "Команда: `rm -f *.log`",
    "Переименование файла": "Команда: `mv oldname.txt newname.txt`",
    "Создание резервной копии файла":
      "Команда: `cp original.conf original.conf.bak`",
    "Мониторинг процессов с htop":
      "Запустите `htop` для интерактивного просмотра процессов и их использования ресурсов.",
    "Автоматическое обновление системы":
      "Команда для Debian/Ubuntu: `sudo apt update && sudo apt upgrade -y`",
    "Настройка постоянного NAT":
      "Команда: `iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE`",
    "Создание нового пользователя и добавление в группу":
      "Команды:\n`sudo adduser newuser`\n`sudo usermod -aG sudo newuser`",
    "Установка пакета с использованием apt":
      "Команда: `sudo apt install nginx -y`",
    "Перезапуск службы": "Команда: `sudo systemctl restart nginx`",
    "Просмотр логов службы": "Команда: `sudo journalctl -u nginx`",
    "Создание символической ссылки":
      "Команда: `ln -s /var/www/html/index.html ~/index.html`",
    "Изменение прав доступа рекурсивно":
      "Команда: `chmod -R 755 /var/www/html`",
    "Поиск и удаление больших файлов":
      "Команда: `find /var/log -type f -size +500M -exec rm -f {} \\;`",
    "Мониторинг сетевых подключений с помощью netstat":
      "Команда: `netstat -tulnp` показывает все активные сетевые подключения и прослушивающие порты.",
    "Создание и монтирование раздела":
      "Команды:\n`fdisk /dev/sdb`\n`mkfs.ext4 /dev/sdb1`\n`mkdir /mnt/data`\n`mount /dev/sdb1 /mnt/data`",
    "Настройка автоматического монтирования раздела при загрузке":
      "Добавьте строку `/dev/sdb1 /mnt/data ext4 defaults 0 2` в файл `/etc/fstab`.",
    "Перезапуск сетевого интерфейса":
      "Команда: `sudo systemctl restart networking` или `sudo ifdown eth0 && sudo ifup eth0`",
    "Изменение IP адреса интерфейса":
      "Команда: `sudo ip addr add 192.168.1.100/24 dev eth0`",
    "Просмотр текущих сетевых маршрутов": "Команда: `ip route show`",
    "Сканирование порта с использованием nmap":
      "Команда: `nmap -p 80,443 192.168.1.1`",
    "Создание SOAP-сервиса с использованием Java и Spring Boot":
      "Пример: Определение WSDL файла, создание классов сервисов и конфигурация Spring Boot для обработки SOAP-запросов.",
    "Реализация bidirectional streaming в gRPC на Go":
      "Пример: Реализация сервера и клиента, которые обмениваются потоками сообщений через gRPC, используя Go библиотеку.",
    "Настройка ESB с использованием Apache Camel для интеграции с Salesforce":
      "Пример: Создание маршрута Camel, который извлекает данные из Salesforce, преобразует их и отправляет в другую систему.",
    "Использование Dead Letter Queue в RabbitMQ":
      "Пример: Конфигурация очереди с DLX (Dead Letter Exchange) и настройка обработки неуспешных сообщений.",
    "Создание и публикация Protocol Buffer схемы для gRPC сервиса":
      "Пример: Определение .proto файла, генерация кода клиента и сервера с помощью protoc, и публикация схемы в репозитории.",
  },
};
